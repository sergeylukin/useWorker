{"version":3,"file":"index.modern.js","sources":["../src/lib/jobRunner.ts","../src/lib/status.ts","../src/lib/createWorkerBlobUrl.ts","../src/lib/remoteDepsParser.ts","../src/useWorker.ts","../src/hook/useDeepCallback.ts"],"sourcesContent":["/* eslint-disable no-restricted-globals */\nimport { TRANSFERABLE_TYPE } from 'src/useWorker'\n\ninterface JOB_RUNNER_OPTIONS {\n  fn: Function,\n  transferable: TRANSFERABLE_TYPE\n}\n\n/**\n * This function accepts as a parameter a function \"userFunc\"\n * And as a result returns an anonymous function.\n * This anonymous function, accepts as arguments,\n * the parameters to pass to the function \"useArgs\" and returns a Promise\n * This function can be used as a wrapper, only inside a Worker\n * because it depends by \"postMessage\".\n *\n * @param {Function} userFunc {Function} fn the function to run with web worker\n *\n * @returns {Function} returns a function that accepts the parameters\n * to be passed to the \"userFunc\" function\n */\nconst jobRunner = (options: JOB_RUNNER_OPTIONS): Function => (e: MessageEvent) => {\n  const [userFuncArgs] = e.data as [any[]]\n  return Promise.resolve(options.fn(...userFuncArgs))\n    .then(result => {\n      const isTransferable = (val: any) => (\n        ('ArrayBuffer' in self && val instanceof ArrayBuffer)\n        || ('MessagePort' in self && val instanceof MessagePort)\n        || ('ImageBitmap' in self && val instanceof ImageBitmap)\n        || ('OffscreenCanvas' in self && val instanceof OffscreenCanvas)\n      )\n      const transferList: any[] = options.transferable === 'auto' && isTransferable(result) ? [result] : []\n      // @ts-ignore\n      postMessage(['SUCCESS', result], transferList)\n    })\n    .catch(error => {\n      // @ts-ignore\n      postMessage(['ERROR', error])\n    })\n}\n\nexport default jobRunner\n","export enum WORKER_STATUS {\n  PENDING = 'PENDING',\n  SUCCESS = 'SUCCESS',\n  RUNNING = 'RUNNING',\n  ERROR = 'ERROR',\n  TIMEOUT_EXPIRED = 'TIMEOUT_EXPIRED',\n}\n\nexport default WORKER_STATUS\n","import isoworker from 'isoworker'\nimport { TRANSFERABLE_TYPE } from 'src/useWorker'\nimport jobRunner from './jobRunner'\nimport remoteDepsParser from './remoteDepsParser'\n\n/**\n * Converts the \"fn\" function into the syntax needed to be executed within a web worker\n *\n * @param {Function} fn the function to run with web worker\n * @param {Array.<String>} deps array of strings, imported into the worker through \"importScripts\"\n *\n * @returns {String} a blob url, containing the code of \"fn\" as a string\n *\n * @example\n * createWorkerBlobUrl((a,b) => a+b, [])\n * // return \"onmessage=return Promise.resolve((a,b) => a + b)\n * .then(postMessage(['SUCCESS', result]))\n * .catch(postMessage(['ERROR', error])\"\n */\nconst createWorkerBlobUrl = (\n  fn: Function,\n  deps: string[],\n  transferable: TRANSFERABLE_TYPE,\n  localDeps: () => unknown[],\n) => {\n  const [context] = isoworker.createContext(localDeps)\n  const blobCode = `\n    ${remoteDepsParser(deps)};\n    ${context}\n    onmessage=(${jobRunner})({\n      fn: (${fn}),\n      transferable: '${transferable}'\n    })\n  `\n  const blob = new Blob([blobCode], { type: 'text/javascript' })\n  const url = URL.createObjectURL(blob)\n  return url\n}\n\nexport default createWorkerBlobUrl\n","/**\n *\n * Concatenates the remote dependencies into a comma separated string.\n * this string will then be passed as an argument to the \"importScripts\" function\n *\n * @param {Array.<String>}} deps array of string\n * @returns {String} a string composed by the concatenation of the array\n * elements \"deps\" and \"importScripts\".\n *\n * @example\n * remoteDepsParser(['http://js.com/1.js', 'http://js.com/2.js']) // return importScripts('http://js.com/1.js, http://js.com/2.js')\n */\nconst remoteDepsParser = (deps: string[]) => {\n  if (deps.length === 0) return ''\n\n  const depsString = (deps.map(dep => `${dep}`)).toString()\n  return `importScripts('${depsString}')`\n}\n\nexport default remoteDepsParser\n","import React from 'react'\nimport createWorkerBlobUrl from './lib/createWorkerBlobUrl'\nimport WORKER_STATUS from './lib/status'\nimport { useDeepCallback } from './hook/useDeepCallback'\n\ntype WorkerController = {\n  status: WORKER_STATUS;\n  kill: Function;\n}\n\nexport enum TRANSFERABLE_TYPE {\n  AUTO = 'auto',\n  NONE = 'none',\n}\n\ntype Options = {\n  timeout?: number;\n  remoteDependencies?: string[];\n  autoTerminate?: boolean;\n  transferable?: TRANSFERABLE_TYPE;\n  localDependencies?: () => unknown[];\n}\n\nconst PROMISE_RESOLVE = 'resolve'\nconst PROMISE_REJECT = 'reject'\nconst DEFAULT_OPTIONS: Options = {\n  timeout: undefined,\n  remoteDependencies: [],\n  autoTerminate: true,\n  transferable: TRANSFERABLE_TYPE.AUTO,\n  localDependencies: () => [],\n}\n\n\n/**\n *\n * @param {Function} fn the function to run with web worker\n * @param {Object} options useWorker option params\n */\nexport const useWorker = <T extends (...fnArgs: any[]) => any>(\n  fn: T, options: Options = DEFAULT_OPTIONS,\n) => {\n  const [workerStatus, _setWorkerStatus] = React.useState<WORKER_STATUS>(WORKER_STATUS.PENDING)\n  const worker = React.useRef<Worker & { _url?: string }>()\n  const isRunning = React.useRef(false)\n  const promise = React.useRef<{\n    [PROMISE_REJECT]?:(result: ReturnType<T> | ErrorEvent) => void;[PROMISE_RESOLVE]?:\n    (result: ReturnType<T>) => void\n  }>({})\n  const timeoutId = React.useRef<number>()\n\n  const setWorkerStatus = React.useCallback((status: WORKER_STATUS) => {\n    isRunning.current = status === WORKER_STATUS.RUNNING\n    _setWorkerStatus(status)\n  }, [])\n\n  const killWorker = React.useCallback(() => {\n    if (worker.current?._url) {\n      worker.current.terminate()\n      URL.revokeObjectURL(worker.current._url)\n      promise.current = {}\n      worker.current = undefined\n      window.clearTimeout(timeoutId.current)\n    }\n  }, [])\n\n  const onWorkerEnd = React.useCallback((status: WORKER_STATUS) => {\n    const terminate = options.autoTerminate != null\n      ? options.autoTerminate\n      : DEFAULT_OPTIONS.autoTerminate\n\n    if (terminate) {\n      killWorker()\n    }\n    setWorkerStatus(status)\n  }, [options.autoTerminate, killWorker, setWorkerStatus])\n\n  const generateWorker = useDeepCallback(() => {\n    const {\n      remoteDependencies = DEFAULT_OPTIONS.remoteDependencies,\n      timeout = DEFAULT_OPTIONS.timeout,\n      transferable = DEFAULT_OPTIONS.transferable,\n      localDependencies = DEFAULT_OPTIONS.localDependencies,\n    } = options\n\n    const blobUrl = createWorkerBlobUrl(fn, remoteDependencies!, transferable!, localDependencies!)\n    const newWorker: Worker & { _url?: string } = new Worker(blobUrl)\n    newWorker._url = blobUrl\n\n    newWorker.onmessage = (e: MessageEvent) => {\n      const [status, result] = e.data as [WORKER_STATUS, ReturnType<T>]\n\n      switch (status) {\n        case WORKER_STATUS.SUCCESS:\n          promise.current[PROMISE_RESOLVE]?.(result)\n          onWorkerEnd(WORKER_STATUS.SUCCESS)\n          break\n        default:\n          promise.current[PROMISE_REJECT]?.(result)\n          onWorkerEnd(WORKER_STATUS.ERROR)\n          break\n      }\n    }\n\n    newWorker.onerror = (e: ErrorEvent) => {\n      promise.current[PROMISE_REJECT]?.(e)\n      onWorkerEnd(WORKER_STATUS.ERROR)\n    }\n\n    if (timeout) {\n      timeoutId.current = window.setTimeout(() => {\n        killWorker()\n        setWorkerStatus(WORKER_STATUS.TIMEOUT_EXPIRED)\n      }, timeout)\n    }\n    return newWorker\n  }, [fn, options, killWorker])\n\n  const callWorker = React.useCallback((...workerArgs: Parameters<T>) => {\n    const { transferable = DEFAULT_OPTIONS.transferable } = options\n    return new Promise<ReturnType<T>>((resolve, reject) => {\n      promise.current = {\n        [PROMISE_RESOLVE]: resolve,\n        [PROMISE_REJECT]: reject,\n      }\n      const transferList: any[] = transferable === TRANSFERABLE_TYPE.AUTO ? (\n        workerArgs.filter((val: any) => (\n          ('ArrayBuffer' in window && val instanceof ArrayBuffer)\n            || ('MessagePort' in window && val instanceof MessagePort)\n            || ('ImageBitmap' in window && val instanceof ImageBitmap)\n            || ('OffscreenCanvas' in window && val instanceof OffscreenCanvas)\n        ))\n      ) : []\n\n      worker.current?.postMessage([[...workerArgs]], transferList)\n\n      setWorkerStatus(WORKER_STATUS.RUNNING)\n    })\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [setWorkerStatus])\n\n  const workerHook = React.useCallback((...fnArgs: Parameters<T>) => {\n    const terminate = options.autoTerminate != null\n      ? options.autoTerminate\n      : DEFAULT_OPTIONS.autoTerminate\n\n    if (isRunning.current) {\n      /* eslint-disable-next-line no-console */\n      console.error('[useWorker] You can only run one instance of the worker at a time, if you want to run more than one in parallel, create another instance with the hook useWorker(). Read more: https://github.com/alewin/useWorker')\n      return Promise.reject()\n    }\n    if (terminate || !worker.current) {\n      worker.current = generateWorker()\n    }\n\n    return callWorker(...fnArgs)\n  }, [options.autoTerminate, generateWorker, callWorker])\n\n  const workerController = {\n    status: workerStatus,\n    kill: killWorker,\n  }\n\n  React.useEffect(() => () => {\n    killWorker()\n  }, [killWorker])\n\n  return [\n    workerHook, workerController,\n  ] as [typeof workerHook, WorkerController]\n}\n","import React, { DependencyList } from 'react'\nimport dequal from 'dequal'\n\nexport const useDeepCallback = <T extends (...args: any[]) => any>(\n  callback: T, dependencies: DependencyList,\n) => {\n  const prevDependencies = React.useRef<DependencyList>(dependencies)\n  const areDeepsEqual = dequal(prevDependencies.current, dependencies)\n  if (!areDeepsEqual) {\n    prevDependencies.current = dependencies\n  }\n\n  return React.useCallback(callback, prevDependencies.current)\n}\n"],"names":["WORKER_STATUS","jobRunner","options","e","Promise","resolve","fn","data","then","result","val","transferList","transferable","self","ArrayBuffer","MessagePort","ImageBitmap","OffscreenCanvas","postMessage","error","createWorkerBlobUrl","deps","localDeps","context","isoworker","createContext","blobCode","length","map","dep","toString","remoteDepsParser","blob","Blob","type","URL","createObjectURL","TRANSFERABLE_TYPE","DEFAULT_OPTIONS","timeout","undefined","remoteDependencies","autoTerminate","AUTO","localDependencies","useWorker","callback","dependencies","prevDependencies","React","useState","PENDING","workerStatus","_setWorkerStatus","worker","useRef","isRunning","promise","timeoutId","setWorkerStatus","useCallback","status","current","RUNNING","killWorker","_worker$current","_url","terminate","revokeObjectURL","window","clearTimeout","onWorkerEnd","generateWorker","blobUrl","newWorker","Worker","onmessage","SUCCESS","ERROR","onerror","setTimeout","TIMEOUT_EXPIRED","dequal","callWorker","workerArgs","reject","filter","workerHook","console","workerController","kill","useEffect"],"mappings":"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"}